---
id: call-graphs
title: Call Graphs
sidebar_label: Call Graphs
description: Call Graphs are an effective means by which to communicate the structure of a distributed application.
last_update:
  date: "03-21-2024"
tags:
  - concepts
  - call-graph
---

import { LabeledDiagram } from "@site/src/components/LabeledDiagram/LabeledDiagram";

Generically, a Call Graph is a directed graph where the nodes are functions and the edges are calls between functions.

<LabeledDiagram>
  <img src="/img/generic-call-graph.svg" alt="Generic Call Graph" />
</LabeledDiagram>

Within the context of the Distributed Async Await specification, and all implementations of it, a Call Graph is the full set of promises and executions from ephemeral edge to ephemeral edge.
That is — a Call Graph is a map of the durable world.

In the Distributed Async Await specification, all execution invocations pair with a promise.

<LabeledDiagram>
  <img src="/img/promise-execution-pair.svg" alt="Promise execution pair" />
</LabeledDiagram>

An execution can be either a function execution or some action that must be taken outside of the system, such as a human clicking a button.

![Promise execution promise action pairs](/img/promise-execution-promise-action-pairs.svg)

A Call Graph can illustrate locality — that is, an execution can display its locality in relation to other executions.
This is called a Distributed Call Graph.

![Execution locality](/img/execution-locality.svg)

A Call Graph is zoomable — that is, it can show the full set of promises and executions, or it can show just the root executions.
Consider the following pseudo-code, where `foo()` and `bar()` are in process a, and `baz()` is in process b.

process a:

```text
func foo():
    r = await (async_local bar())
    return r

func bar():
    r = await (async_remote baz())
    return r
```

process b:

```text
func baz():
    return 1
```

If the Call Graph zooms in on all the promises, function executions, and localities (details, concurrency, and distribution), it would look like this:

![Detailed distributed concurrent Call Graph](/img/detailed-distributed-concurrent-call-graph.svg)

This same call structure can assume promises and the Call Graph can just show the function executions.

![Detailed distributed concurrent Call Graph](/img/distributed-concurrent-call-graph.svg)

To show just the distributed nature of the application, we can zoom out and show just the root executions of each process.

![Distributed Call Graph](/img/distributed-call-graph.svg)

## Local and Remote

When a function calls another function within the same process it is called a Local Function Invocation (LFI).

{/* ![Diagram of an LFI Call Graph](/img/lfc-call-graph.svg) */}

When a function calls another function in a different Application Node, it is considered a Remote Function Invocation (RFI).

{/* ![Diagram of an RFI Call Graph](/img/rfc-call-graph.svg) */}

A Resonate Application can make use of both LFIs and RFIs, and thus a Resoante Call Graph can span just one or many Application Nodes.

{/* ![Diagram of a Resonate Call Graph spanning multiple Application Nodes](/img/complex-rfc-call-graph.svg) */}

## Root promises

There are two types of root promises.
The first is the root promise of an Application Node (process), and the second is the root promise of a Call Graph.

An Application Node root promise (also known as the process) is the promise associated with the first execution in an Application Node.
In other words, this is the execution invoked by `resonate.run()`.

A Call Graph root promise is the promise associated with the first execution in a Call Graph.
This execution is also invoked by `resonate.run()`, but it is on the "edge" and is typically the entry point into the application.

{/* ![Diagram of a Resonate Call Graph with labeled root promises](/img/labeled-complex-rfc-call-graph.svg) */}
