"use strict";(self.webpackChunkresonate=self.webpackChunkresonate||[]).push([[314],{1712:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"specification/message-passing-protocol","title":"Message Passing Protocol","description":"The Distributed Async Await protocol set is based on low-level message-passing semantics.","source":"@site/docs/specification/message-passing-protocol.mdx","sourceDirName":"specification","slug":"/specification/message-passing-protocol","permalink":"/specification/message-passing-protocol","draft":false,"unlisted":false,"editUrl":"https://github.com/resonatehq/daa-spec.resonatehq.io/tree/main/docs/specification/message-passing-protocol.mdx","tags":[],"version":"current","frontMatter":{"id":"message-passing-protocol","title":"Message Passing Protocol","sidebar_label":"Message Passing Protocol"},"sidebar":"defaultSidebar","previous":{"title":"Distributed Recovery Protocol","permalink":"/specification/distributed-recovery-protocol"},"next":{"title":"System Model","permalink":"/system-model/"}}');var t=n(4848),o=n(8453);const a={id:"message-passing-protocol",title:"Message Passing Protocol",sidebar_label:"Message Passing Protocol"},r=void 0,c={},d=[];function l(e){const s={code:"code",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"The Distributed Async Await protocol set is based on low-level message-passing semantics.\nX.0 Objective\nThe Message-Passing Protocol MUST support a wide array of transport mechanisms such as push or poll over http or message queues. Therefore, the specification defines the behavior of sending and receiving messages between processes with minimal requirements and minimal guarantees.\nX.1 Messaging\nEvery component may issue a Send(address, message) command that will result in emitting a Send(address, message) event."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"command Send<T>(address : Address, message : T)\n"})}),"\n",(0,t.jsx)(s.p,{children:"X.2 Addressing\nProcesses communicate via addresses. Distributed Async Await supports two types of addresses, UniCast addresses and AnyCast addresses."}),"\n",(0,t.jsx)(s.p,{children:"UniCast. A UniCast address denotes an individual process.\nAnyCast. An AnyCast address denotes a group of processes."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"data Address =\n  | UniCast PSpecifier\n  | AnyCast GSpecifier x optional<PSpecifier>\n"})}),"\n",(0,t.jsx)(s.p,{children:"PSpecifier denotes a transport-specific specifier specifying a single progress"}),"\n",(0,t.jsx)(s.p,{children:"GSpecifier denotes a transport-specific specifier specifying a group of processes"}),"\n",(0,t.jsx)(s.p,{children:"X.3 Address Resolution\nThis specification does not determine how and when addresses are resolved. Specifically, this specification does not determine whether addresses are resolved on send (early binding) or on recv (late binding)."}),"\n",(0,t.jsx)(s.p,{children:"X.4 Send as a Foundations of Failover\nThe Send command is the foundation of Distributed Async Await\u2019s failover mechanics: Send\u2019s AnyCast semantics enables both routing as well as transparent rerouting in case of failure. This ensures that distributed executions can adapt dynamically to changes in the process topology automatically.\nInvoke-Resume Example: The Canonical Interaction"}),"\n",(0,t.jsx)(s.p,{children:"The canonical interaction in Distributed Async Await involves invoking and awaiting an asynchronous function remotely (see Distributed Coordination Protocol). This interaction involves two messages:"}),"\n",(0,t.jsx)(s.p,{children:"Invoke\nRepresents the request to invoke an execution"}),"\n",(0,t.jsx)(s.p,{children:"Resume\nRepresents the request to resume an awaiting execution"}),"\n",(0,t.jsx)(s.p,{children:"The following example illustrates how Send\u2019s AnyCast semantics enable reliable failover in a distributed system."})]})}function p(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>r});var i=n(6540);const t={},o=i.createContext(t);function a(e){const s=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(o.Provider,{value:s},e.children)}}}]);